<!DOCTYPE html>
<html>
	<head>
		<title>Tracer</title>
		<link rel="stylesheet" href="style.css" type="text/css">

	</head>
	<body>
        <div style="text-align:center">
            <canvas id="c" width="800" height="600" style="border:1px solid #000;"></canvas>
        </div>
        <script id="vs" type="notjs">
            attribute vec2 a_pixel;    
            uniform mat4 u_matrix;
            varying vec3 pixel;

            void main() {
                pixel = vec3(a_pixel + vec2(0.5, 0.5), -500.0);
                gl_Position = u_matrix * vec4(a_pixel, 0.0, 1.0);
                gl_PointSize = 1.0;
            }
        </script>
		<script id="fs" type="notjs">
            precision mediump float;

            struct Mat {
                int i; // diffuse - 1, metal - 2
                vec3 att; // attenuation
            };

            struct Sphere {
                vec3 o;
                float r;
                Mat mat;
            };

            struct Cam {
                vec3 o;
                vec3 gaze;
                vec3 up;
                float focal;
            };

            struct Ray {
                vec3 o;
                vec3 d;
            };

            struct Hit {
                float t;
                vec3 p;
                vec3 n;
                Mat mat;
            };
            
            uniform float w;
            uniform float h;
            uniform float u_seed;
            uniform Sphere u_spheres[10];
            uniform vec3 u_cursor;
            uniform int u_sample_count;

            varying vec3 pixel;
            vec4 bg_color = vec4(0.4, 0.4, 0.0, 1.0);
            const float pi = 3.141592653589;
            float n_seed = u_seed;

            Sphere spheres[10];
            Cam cam = Cam(vec3(0., 0., 6000.), vec3(0, 0, -1.0), vec3(0, 1.0, 0), 10.);

            vec3 light = vec3(500., -500., 500.);

            // Unitilities 
            // 0 ~ 1.0
            float random(inout float seed) {
                vec3 scale = vec3(12.9898, 78.233, 151.7182);
                seed += 1.1;
                if (seed > 10000000.0) seed = 0.0;
                return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
            }

            vec3 random_unit_vector() {
                float a = random(n_seed) * 2.0 * pi;
                float z = random(n_seed) * 2.0 - 1.0;
                float r = sqrt(1.0 - z * z);
                return vec3(r * cos(a), r * sin(a), z);
            }

            mat2 transpose(mat2 m) {
              return mat2(m[0][0], m[1][0],
                          m[0][1], m[1][1]);
            }

            mat3 transpose(mat3 m) {
              return mat3(m[0][0], m[1][0], m[2][0],
                          m[0][1], m[1][1], m[2][1],
                          m[0][2], m[1][2], m[2][2]);
            }

            mat4 transpose(mat4 m) {
              return mat4(m[0][0], m[1][0], m[2][0], m[3][0],
                          m[0][1], m[1][1], m[2][1], m[3][1],
                          m[0][2], m[1][2], m[2][2], m[3][2],
                          m[0][3], m[1][3], m[2][3], m[3][3]);
            }


            bool intersectSphere(in Ray ray, Sphere sphere, float t_min, out float t) {
                float a = dot(ray.d, ray.d);
                float half_b = dot(ray.d, ray.o - sphere.o);
                float c = dot(ray.o - sphere.o, ray.o - sphere.o) - sphere.r * sphere.r;
                float qua_delta	= half_b * half_b - a * c;
                if (qua_delta < 0.0) return false;
                t = (- half_b - sqrt(qua_delta)) / a; // smaller root
                if (t > t_min) return true;
                t = (- half_b + sqrt(qua_delta)) / a; // larger root
                if (t > t_min) return true;
                return false;
            }

            bool intersect(in Ray ray, out Hit hit) {
                bool did_hit = false;
                for (int i = 0; i < 10; i++) {
                	float t;
                    if (intersectSphere(ray, spheres[i], 0.0, t)) {
                        if (!did_hit || t < hit.t) {
                            did_hit = true;
                            hit.t = t;
                            hit.p = ray.o + ray.d * t;
                    	    hit.n = normalize(hit.p - spheres[i].o);
                            hit.mat = spheres[i].mat;
                        }   
                    }
                }
                return did_hit;
            }

            vec3 randPointInSphere() {
                vec3 off = vec3(0.0, 0.0, 0.0);
                for (int i = 0; i < 100000; i++) {
                    off = vec3(random(n_seed) * 2.0 - 1.0, random(n_seed) * 2.0 - 1.0, random(n_seed) * 2.0 - 1.0);
                    if (dot(off, off) > 1.0) continue;
                    return off;
                }
                return off;
            }

            bool shoot_ray(in Ray ray, inout vec4 color, out Hit hit) {
                if (!intersect(ray, hit)) return false;                
                color = vec4(0.5 * vec3(hit.n.x + 1.0, hit.n.y + 1.0, hit.n.z + 1.0) * dot(hit.n, normalize(light - hit.p)), 1.0);
                return true;
            }

            bool shoot_rays(in Ray ray, inout vec4 color) {
                bool did_hit = false;
                for (int i = 0; i < 100; i++) {
                    if (i > u_sample_count) break;
                    Ray nr;
                    nr.o = ray.o;
                    nr.d = ray.d + vec3(random(n_seed) - 0.5, random(n_seed) - 0.5, 0);
                    Hit hit;
                    vec4 single_color;
                    float fac = 1.0;
                    vec3 fac3 = vec3(1.0);
                    for (int d = 0; d < 5; d++) {
                        if (shoot_ray(nr, single_color, hit)) {
                            did_hit = true;
                            if (hit.mat.i == 1) {
                                fac = 0.5 * fac;
                                vec3 target = hit.p + hit.n + random_unit_vector();
                                nr.o = hit.p;
                                nr.d = target - hit.p;
                            } else {
                                fac3 = vec3(hit.mat.att.x * fac3.x, hit.mat.att.y * fac3.y, hit.mat.att.z * fac3.z);
                                vec3 reflect = nr.d - 2.0 * dot(nr.d, hit.n) * hit.n;
                                nr.o = hit.p;
                                nr.d = reflect;
                                if (dot(reflect, hit.n) < 0.0) continue;
                            }
                        } else {
                            if (!did_hit) {
                                color = color + fac * bg_color;
                            } else if (hit.mat.i == 1) {
                                color = color + fac * vec4(hit.mat.att, 1.0);
                            } else {
                                color = color + vec4(fac3.x * bg_color.x, fac3.y * bg_color.y, fac3.z * bg_color.z, 1.0);
                            }
                            break;
                        }
                    }
                }
                return did_hit;
            }

            vec4 out_color(in vec4 color, in int sample_count) {
                float sample_count_f = float(sample_count);
                float scale = 1.0 / sample_count_f;
                return vec4(sqrt(color.x * scale), sqrt(color.y * scale), sqrt(color.z * scale), 1.0);
            }

            void main() {
                float yaw = u_cursor[0];
                float pitch = - u_cursor[1];
                mat4 r_yaw = mat4(cos(yaw), -sin(yaw), 0, 1.,
                                sin(yaw), cos(yaw), 0, 1.,
                                0, 0, 1., 0.,
                                0, 0, 0, 1.);
                mat4 r_pitch = mat4(1., 0, 0, 0,
                                    0, cos(pitch), -sin(pitch), 0,
                                    0, sin(pitch), cos(pitch), 0,
                                    0, 0, 0, 1.);
                mat4 rot = r_pitch*r_yaw;
                cam.gaze = vec3(rot * vec4(cam.gaze, 1.0));
                cam.o = vec3(rot * vec4(cam.o, 1.0));
                cam.up = vec3(rot * vec4(cam.up, 1.0));

                vec3 gu = normalize(cross(cam.gaze, cam.up));
                mat4 rotate = mat4(transpose(mat3(gu, cam.up, -cam.gaze)));
                mat4 tran = mat4(1., 0., 0., 0.,
                                0., 1., 0., 0.,
                                0., 0., 1., 0.,
                                -cam.o.x, -cam.o.y, -cam.o.z, 0.);

                mat4 view = rotate * tran;

                for (int i = 0; i < 10; i++) {
                    spheres[i] = u_spheres[i];
                    spheres[i].o = vec3(view * vec4(spheres[i].o, 1.));
                }

                Ray ray;
                ray.o = vec3(0);
                ray.d = pixel - ray.o;
                vec4 color = vec4(0);
                float t = 0.5 * (normalize(ray.d).y + 1.0);
                bg_color = (1.0 - t) * vec4(1.0) + t * bg_color;
                shoot_rays(ray, color);
                gl_FragColor = out_color(color, u_sample_count);
            }

		</script>
        <script src="vector.js"></script>
        <script src="matrix.js"></script>
		<script src="main.js"></script>
	</body>
</html>
